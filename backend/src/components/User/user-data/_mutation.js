import {
  Organization,
  User,
  Team,
  TeamStageResult,
  UserProfile,
  UserContentInteractions,
  ArchivedContentInteractionData,
  UserProgress,
  Skills,
  Goal,
  DevelopmentPlan,
  OrganizationSettings,
  RoleRequirements,
  LearningPathTemplate,
  ContentSources
} from '~/models'
import { isInnentialAdmin, isUser, isAdmin } from '~/directives'
import {
  typeform,
  encryptor,
  appUrls,
  sendEmail,
  sentryCaptureException,
  // employeeInvitationTemplate,
  adminInvitationTemplate,
  s3,
  firstInvitationTemplate,
  getDownloadLink,
  registrationTemplate,
  feedbackRequestNotification,
  organizationRegisteredNotification
} from '~/utils'
import axios from 'axios'
import { createTokens } from '~/authentication'
import { AUTH, ROLES_PERMISSIONS, SCOPES, agenda } from '~/config'
import { Types } from 'mongoose'
import UserEvaluation from '../../../models/UserEvaluation'
import getUserOnboardingInfo from './utils/_getUserOnboardingInfo'
import GokuArray from 'goku-array'
import slugfunction from 'slug'
import getUsersForNotification from './utils/_getUsersForNotification'
import { ENVIRONMENT } from '../../../environment'
import { analytics, mailchimp } from '../../../config'
import md5 from 'md5'
// const slugfunction = require('slug')

// onboardUser(inputData: UserProfileInput!): String @${isUser}

const generateNameForSkills = skills =>
  skills.length > 0
    ? `Learn about ${skills
        .slice(0, 3)
        .map(({ name }, i, { length }) => {
          if (i === 0) return name
          if (i < length - 1) return `, ${name}`
          if (i === length - 1 && skills.length < 4) return ` and ${name}`
          return `, ${name} and others`
        })
        .join('')}`
    : ''

export const mutationTypes = `
    type Mutation {
      deleteUser(userId: ID!): String @${isInnentialAdmin}
      deleteUserFromOrganization(userId: ID!, organizationId: ID!): String @${isAdmin}
      deleteUserFromTeam(userId: ID!, teamId: ID!): String @${isInnentialAdmin}
      onboardUserPersonalInfo(inputData: UserOnboardingPersonalInfo!): [Skill] @${isUser}
      onboardUserDevelopmentPlan(inputData: UserOnboardingDevelopmentPlan!): String @${isUser}
      promoteUser(userId: ID!): Employees @${isAdmin}
      profileSkillsChangeMutation(inputData: UserProfileSkillsChangeInput!): UserProfile @${isUser}
      profilePositionChangeMutation(inputData: UserProfilePositionChangeInput!): UserProfile @${isUser}
      profileGrowthChangeMutation(inputData: UserProfileGrowthChangeInput!): UserProfile @${isUser}
      profilePasswordChangeMutation(inputData: UserProfilePasswordChangeInput!): String @${isUser}
      profileNameChangeMutation(firstName: String, lastName: String): String @${isUser}
      addNewUser(email: String!, role: String!, invite: Boolean): Employees @${isAdmin}
      publicRegisterUser(userData: UserRegisterInput!, metaData: RegistrationMetaInput): String
      publicRegisterUserAcceptInvitation(pendingInvitation: String!): CompleteUserProfile
      updateNeededSkills(neededWorkSkills: [UserProfileSkillsInput]!): UserProfile @${isUser}
      updateLearningPreferences(types: [String], sortMethod: String, price: [String]): String @${isUser}
      deleteProfileImage: String @${isUser}
      toggleWeeklyEmail(userId: String): String @${isInnentialAdmin}
      setUsersLocation(location: String): User @${isUser}
      editDisabledProfile(inputData: UserProfileEditInput!): CompletePublicProfile @${isAdmin}
      inviteDisabledUser(userId: ID!, deleteData: Boolean): String @${isAdmin}
      assessSkills(skills: [UserProfileSkillsInput]!): UserProfile @${isUser}
      disableApprovalPrompt: User @${isUser}
    }
`

// MAILCHIMP LIST ID
const listId = process.env.MAILCHIMP_LIST_ID

const { innentialFbUrl } = typeform

// const createGoalsForProfile = async (
//   { neededWorkSkills, user },
//   organizationId
// ) => {
//   await Promise.all(
//     neededWorkSkills.map(async workSkill => {
//       const skill = await Skills.findById(workSkill._id)

//       const goalName = `Improve ${skill.name} skills`
//       await Goal.create({
//         goalName,
//         goalType: 'PERSONAL',
//         setBy: user,
//         organizationId,
//         user,
//         relatedSkills: [skill._id],
//         status: 'DRAFT',
//         autogenerated: true
//       })
//     })
//   )
// }

const mapApprovals = (organization, context, goal) => /* async */ async ({
  contentId,
  contentType,
  price,
  subscriptionAvailable
}) => {
  const approved =
    !organization ||
    !organization.approvals ||
    context.user.roles.includes('ADMIN') ||
    price === 0
  const learningContent = await context.dataSources.LearningContent.findById(
    contentId
  )
  const contentSource = await ContentSources.findById(learningContent.source)
  const status =
    (organization &&
      organization.fulfillment &&
      price > 0 &&
      !subscriptionAvailable) ||
    (contentSource.accountRequired && organization.fulfillment)
      ? 'AWAITING FULFILLMENT'
      : 'NOT STARTED'

  return {
    contentId,
    contentType,
    goalId: goal._id,
    approved,
    status
  }
}

const recordUsersProgress = async (
  { user, ...profile }, // UserProfile
  updatedKeys // ['selectedInterests', 'selectedWorkSkills'. 'neededWorkSkills']
) => {
  const usersProgress = await UserProgress.findOne({ user }).lean()
  const mapItems = key => {
    if (key === 'selectedInterests')
      return ({ _id, slug }) => ({ interestId: _id, slug })
    else if (key === 'selectedWorkSkills')
      return ({ _id, slug, level }) => ({ skillId: _id, slug, level })
    else if (key === 'neededWorkSkills')
      return ({ _id, slug }) => ({ skillId: _id, slug })
    else {
      throw new Error(
        `Invalid key supplied to recordUsersProgress() key=${key}`
      )
    }
  }

  let updatedProgress = { user }
  if (usersProgress) {
    updatedKeys.forEach(key => {
      const previousEntry = usersProgress[key] && usersProgress[key][0]
      if (previousEntry) {
        const snapshot = profile[key].map(mapItems(key))
        const lastChanged = new Date(Date.now() - previousEntry.changedAt)
        if (lastChanged.getMinutes() > 5) {
          // TODO: CHANGE TO HOURS - This is for testing purposes!
          updatedProgress[key] = usersProgress[key]
          updatedProgress[key].unshift({ snapshot })
        } else {
          updatedProgress[key] = usersProgress[key]
          updatedProgress[key][0] = { snapshot }
        }
      } else {
        const snapshot = profile[key].map(mapItems(key))
        updatedProgress[key] = [{ snapshot }]
      }
    })

    await UserProgress.findOneAndUpdate(
      { user },
      {
        $set: updatedProgress
      },
      { new: true }
    )
  } else {
    updatedKeys.forEach(key => {
      const snapshot = profile[key].map(mapItems(key))
      updatedProgress[key] = [{ snapshot }]
    })

    await UserProgress.create(updatedProgress)
  }
}
export const mutationResolvers = {
  Mutation: {
    promoteUser: async (_, { userId }) => {
      try {
        const result = await User.findOneAndUpdate(
          { _id: userId },
          {
            $addToSet: {
              roles: 'ADMIN'
            }
          },
          { new: true, lean: true }
        )
        const employeeTeams = await Team.find({
          $or: [{ leader: userId }, { members: userId }],
          active: true
        })
          .select({ _id: 1, teamName: 1 })
          .lean()
        const employeeProfile = await UserProfile.findOne({ user: userId })
          .select({ _id: 1, roleAtWork: 1 })
          .lean()
        const imageLink = await getDownloadLink({
          key: 'users/profileImgs',
          expires: 500 * 60,
          _id: userId
        })
        return {
          ...result,
          teamInfo:
            employeeTeams.length > 0
              ? `Teams: ${employeeTeams.map(team => team.teamName).join(', ')}`
              : 'Teams: -',
          imageLink,
          roleAtWork: employeeProfile ? employeeProfile.roleAtWork : ''
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    deleteUser: async (_, { userId }) => {
      const user = await User.findById(userId)
      if (!user) throw new Error('A user with provided _id could not be found')
      const { organizationId } = user
      const organization = await Organization.findById(organizationId)
      if (!organization) {
        console.log('this user did not have an organization')
      } else {
        if (organization.admins.some(admin => admin.equals(user._id))) {
          const currentAdmins = organization.admins
          if (currentAdmins.length > 1) {
            const newAdmins = currentAdmins.filter(
              admin => !admin.equals(user._id)
            )
            await Organization.findOneAndUpdate(
              { _id: organization._id },
              { $set: { admins: newAdmins } }
            )
          } else {
            throw new Error(
              'An organization needs to have at least 1 administrator. Please add another one before removing this user'
            )
          }
        }
      }

      const teams = await Team.find({ organizationId })
      if (teams.length > 0) {
        try {
          await Promise.all(
            teams.map(async team => {
              if (team.leader.equals(user._id)) {
                await Team.findOneAndUpdate(
                  { _id: team._id },
                  {
                    $set: {
                      active: false
                    }
                  }
                )
                await TeamStageResult.deleteOne({
                  teamId: team._id,
                  engagement: null
                })
              } else {
                const newMembers = team.members.filter(
                  member => !member.equals(user._id)
                )
                await Team.findOneAndUpdate(
                  { _id: team._id },
                  {
                    $set: {
                      members: [...newMembers]
                    }
                  }
                )
                const openAssessment = await TeamStageResult.findOne({
                  teamId: team._id,
                  assessmentIterator: team.stageAssessments
                })

                if (openAssessment) {
                  const userData = {
                    email: user.email
                  }
                  await axios
                    .post(`${innentialFbUrl}/team=${team._id}/remove`, userData)
                    .catch(err => {
                      throw new Error(err)
                    })
                }
              }
            })
          )
        } catch (e) {
          sentryCaptureException(e)
        }
      }
      // Remove user profiles

      const userProfile = await UserProfile.findOne({ user: user._id })
      if (userProfile) {
        await UserProfile.findByIdAndRemove(userProfile._id)
      }
      const contentProfile = await UserContentInteractions.findOne({
        user: user._id
      })
      if (contentProfile) {
        const result = await UserContentInteractions.findByIdAndRemove(
          contentProfile._id
        )
        const { likedContent, dislikedContent } = result
        await ArchivedContentInteractionData.create({
          likedContent,
          dislikedContent
        })
      }

      try {
        const result = await User.findByIdAndRemove(userId)
        return result
      } catch (e) {
        sentryCaptureException(e)
      }
    },
    addNewUser: async (_, { email, role, invite }, context) => {
      const { _id } = context.user
      try {
        const userCheck = await User.findOne({ email })
        if (userCheck) {
          return 'User already exists'
        }
        const adminUser = await User.findById(_id)
        const organization = await Organization.findById(
          adminUser.organizationId
        )

        const invitingPerson = {
          name: `${adminUser.firstName} ${adminUser.lastName}`,
          roleAtWork: await adminUser.getRoleAtWork(),
          imgLink: await getDownloadLink({
            _id: adminUser._id,
            key: 'users/profileImgs',
            expires: 604800
          })
        }

        const newUser = await User.create({
          email,
          // firstName,
          roles:
            role === 'Admin'
              ? [ROLES_PERMISSIONS.ADMIN.NAME, ROLES_PERMISSIONS.USER.NAME]
              : [ROLES_PERMISSIONS.USER.NAME],
          permissions: [
            ...ROLES_PERMISSIONS.USER.PERMISSIONS[SCOPES.OPERATION.READ].map(
              permission => `${SCOPES.OPERATION.READ}:${permission}`
            )
          ],
          organizationId: organization._id,
          status: invite ? 'invited' : 'disabled',
          ...(invite && {
            invitation: {
              pendingInvitation: new Types.ObjectId(),
              invitedOn: Date.now()
            }
          })
        })

        const usersForEmail = await getUsersForNotification({
          organizationId: organization._id
        })

        if (newUser) {
          const appLink = `${appUrls['user']}`
          if (role === 'Admin') {
            await Organization.findOneAndUpdate(
              { _id: organization._id },
              { admins: [...organization._doc.admins, newUser._id] }
            )
            appLink &&
              invite &&
              (await sendEmail(
                newUser.email,
                `${invitingPerson.name} invited you to join Innential`,
                firstInvitationTemplate({
                  invitingPerson,
                  organizationName: organization.organizationName,
                  invitation: newUser.invitation.pendingInvitation,
                  appUrl: appLink,
                  users: usersForEmail,
                  totalCount:
                    (await User.countDocuments({
                      organizationId: organization._id,
                      status: 'active'
                    })) - usersForEmail.length
                })
              ))
          } else {
            appLink &&
              invite &&
              (await sendEmail(
                newUser.email,
                `${invitingPerson.name} invited you to join Innential`,
                firstInvitationTemplate({
                  invitingPerson,
                  organizationName: organization.organizationName,
                  invitation: newUser.invitation.pendingInvitation,
                  appUrl: appLink,
                  users: usersForEmail,
                  totalCount:
                    (await User.countDocuments({
                      organizationId: organization._id,
                      status: 'active'
                    })) - usersForEmail.length
                })
              ))
          }

          return newUser
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    deleteUserFromOrganization: async (_, { userId, organizationId }) => {
      const user = await User.findById(userId)
      if (!user) throw new Error('A user with provided _id could not be found')

      if (user && user.roles.includes('INNENTIAL_ADMIN'))
        throw new Error('You can not remove an innential admin!')

      const organization = await Organization.findById(organizationId)
      if (!organization)
        throw new Error('An organization with provided _id could not be found')

      if (!user.organizationId)
        throw new Error('The user is not connected to any organization')
      if (user.organizationId !== organizationId)
        throw new Error('The user has no connection with the organization')

      if (organization.admins.some(admin => admin.equals(user._id))) {
        const currentAdmins = organization.admins
        if (currentAdmins.length > 1) {
          const newAdmins = currentAdmins.filter(
            admin => !admin.equals(user._id)
          )
          await Organization.findOneAndUpdate(
            { _id: organization._id },
            { $set: { admins: newAdmins } }
          )
        } else {
          throw new Error(
            'An organization needs to have at least 1 administrator. Please add another one before removing this user'
          )
        }
      }

      // Remove user from all teams (note: if leader, the team will be deleted)
      const teams = await Team.find({ organizationId })
      if (teams.length > 0) {
        try {
          await Promise.all(
            teams.map(async team => {
              if (team.leader.equals(user._id)) {
                await Team.findOneAndUpdate(
                  { _id: team._id },
                  {
                    $set: {
                      active: false
                    }
                  }
                )
                await TeamStageResult.deleteOne({
                  teamId: team._id,
                  engagement: null
                })
              } else {
                const newMembers = team.members.filter(
                  member => !member.equals(user._id)
                )
                await Team.findOneAndUpdate(
                  { _id: team._id },
                  {
                    $set: {
                      members: [...newMembers]
                    }
                  }
                )
                const openAssessment = await TeamStageResult.findOne({
                  teamId: team._id,
                  assessmentIterator: team.stageAssessments
                })

                if (openAssessment) {
                  const userData = {
                    email: user.email
                  }
                  await axios
                    .post(`${innentialFbUrl}/team=${team._id}/remove`, userData)
                    .catch(err => {
                      throw new Error(err)
                    })
                }
              }
            })
          )
        } catch (e) {
          sentryCaptureException(e)
        }
      }

      try {
        if (user.status !== 'active') {
          await User.findByIdAndRemove(userId)
          await UserProfile.deleteOne({ user: userId })
        } else {
          await User.findOneAndUpdate(
            { _id: userId },
            {
              $unset: { organizationId }
            }
          )
          await UserProfile.findOneAndUpdate(
            { user: userId },
            {
              $unset: { organizationId }
            }
          )
        }
        return 'success'
      } catch (e) {
        sentryCaptureException(e)
      }
    },
    deleteUserFromTeam: async (_, { userId, teamId }) => {
      const user = await User.findById(userId)
      if (!user) throw new Error('A user with provided _id could not be found')

      const team = await Team.findById(teamId)
      if (!team) throw new Error('No such team')

      const leaderUser = await User.findById(team.leader)

      try {
        if (user.email === leaderUser.email) {
          throw new Error(`Team must have a leader`)
        } else {
          const newMembers = team.members.filter(
            member => !member.equals(user._id)
          )
          await Team.findOneAndUpdate(
            { _id: teamId },
            {
              $set: {
                members: [...newMembers]
              }
            }
          )

          const openAssessment = await TeamStageResult.findOne({
            teamId: team._id,
            assessmentIterator: team.stageAssessments
          })

          if (openAssessment) {
            const userData = {
              _id: user._id,
              email: user.email
            }

            await axios
              .post(`${innentialFbUrl}/team=${team._id}/remove`, userData)
              .catch(err => {
                console.log(err)
              })
          }

          return user.email
        }
      } catch (e) {
        sentryCaptureException(e)
      }
    },
    // onboardUser: async (_, { inputData }, context) => {
    //   try {
    //     const user = await User.findOne({ _id: context.user._id })
    //     if (user) {
    //       let roleId = inputData.roleId
    //       if (inputData.suggestRole) {
    //         const role = await RoleRequirements.findOne({
    //           title: inputData.roleAtWork,
    //           organizationId: context.user.organizationId
    //         })
    //           .select({ _id: 1 })
    //           .lean()

    //         if (!role) {
    //           const result = await RoleRequirements.create({
    //             title: inputData.roleAtWork,
    //             organizationId: context.user.organizationId,
    //             userId: context.user._id,
    //             suggestion: true,
    //             coreSkills: inputData.selectedWorkSkills.map(
    //               ({ _id, slug, level }) => ({
    //                 skillId: _id,
    //                 slug,
    //                 level
    //               })
    //             )
    //           })
    //           roleId = result._id
    //         }
    //       }

    //       let finalData = {
    //         ...inputData,
    //         roleId,
    //         organizationId: context.user.organizationId
    //       }
    //       delete finalData.suggestRole
    //       await User.findOneAndUpdate(
    //         { _id: user._id },
    //         { $set: { status: 'active' } }
    //       )
    //       const prevProfile = await UserProfile.findOne({ user: user._id })

    //       if (prevProfile) {
    //         const newProfile = await UserProfile.findOneAndUpdate(
    //           { user: user._id },
    //           finalData,
    //           { new: true }
    //         )
    //         await recordUsersProgress(newProfile._doc, [
    //           'selectedWorkSkills',
    //           'selectedInterests',
    //           'neededWorkSkills'
    //         ])

    //         await createGoalsForProfile(
    //           newProfile._doc,
    //           context.user.organizationId
    //         )

    //         // SCHEDULE GOALS NOTIFICATION

    //         agenda.schedule('in one hour', 'singleUserGoalReminder', {
    //           userId: user._id
    //         })

    //         const prevPlan = await DevelopmentPlan.findOne({ user: user._id })
    //         if (!prevPlan)
    //           await DevelopmentPlan.create({
    //             user: user._id,
    //             setBy: user._id,
    //             organizationId: context.user.organizationId
    //           })
    //       } else {
    //         const newProfile = await UserProfile.create(finalData) //eslint-disable-line
    //         const prevInteractions = await UserContentInteractions.findOne({
    //           user: user._id
    //         })
    //         if (!prevInteractions)
    //           await UserContentInteractions.create({ user: user._id })

    //         await recordUsersProgress(newProfile._doc, [
    //           'selectedWorkSkills',
    //           'selectedInterests',
    //           'neededWorkSkills'
    //         ])

    //         await createGoalsForProfile(
    //           newProfile._doc,
    //           context.user.organizationId
    //         )
    //         const prevPlan = await DevelopmentPlan.findOne({ user: user._id })
    //         if (!prevPlan)
    //           await DevelopmentPlan.create({
    //             user: user._id,
    //             setBy: user._id,
    //             organizationId: context.user.organizationId
    //           })
    //       }
    //       return 'User successfully created!'
    //     } else {
    //       console.log('USER NOT FOUND!')
    //       return null
    //     }
    //   } catch (e) {
    //     sentryCaptureException(e)
    //     return null
    //   }
    // },
    onboardUserPersonalInfo: async (
      _,
      { inputData },
      { user: { _id, organizationId }, dataSources }
    ) => {
      try {
        const user = await User.findOne({ _id })

        const organization = await Organization.findOne({ _id: organizationId })
          .select({ premium: 1, corporate: 1 })
          .lean()

        if (user && organization) {
          const {
            roleAtWork: title,
            firstName,
            lastName,
            technician
          } = inputData

          let { roleId } = inputData

          let skillsToEvaluate = []

          // FIND ROLE WITH SAME TITLE, OR CREATE ROLE SUGGESTION

          const role = await RoleRequirements.findOne(
            roleId ? { _id: roleId } : { title, organizationId }
          )
            .select({ _id: 1, coreSkills: 1 })
            .lean()

          if (role) {
            roleId = role._id
            if (organization.premium) {
              // ONBOARDING CHECKLIST: TEMPORARY SOLUTION
              skillsToEvaluate = await Promise.all(
                role.coreSkills.map(async core =>
                  Skills.findOne({ _id: core.skillId })
                )
              )
            }
          } else {
            const result = await RoleRequirements.create({
              title,
              organizationId,
              userId: _id,
              suggestion: true,
              coreSkills: []
            })
            roleId = result._id
          }

          // SET FIRST AND LAST NAME
          await User.findOneAndUpdate(
            { _id: user._id },
            {
              $set: {
                firstName,
                lastName,
                technician
                // status: 'active'
              }
            }
          )

          try {
            // ADD FIRSTNAME, LASTNAME TO USER IN LIST
            const subscriberHash = md5(user.email.toLowerCase())

            await mailchimp.lists.updateListMember(listId, subscriberHash, {
              merge_fields: {
                FNAME: firstName,
                LNAME: lastName
              }
            })
          } catch (err) {
            sentryCaptureException(
              `Failed to modify user ${user._id} in mailchimp list: ${err.message}`
            )
          }

          const existingProfile = await UserProfile.findOneAndUpdate(
            { user: user._id },
            {
              $set: {
                roleAtWork: title,
                roleId
              }
            },
            { new: true }
          )

          if (!existingProfile) {
            await dataSources.UserProfile.createOne({
              organizationId,
              user: user._id,
              roleAtWork: title,
              roleId
            })
            // await UserProfile.create({
            //   organizationId,
            //   user: user._id,
            //   roleAtWork: title,
            //   roleId
            // })
          }

          const prevInteractions = await UserContentInteractions.findOne({
            user: user._id
          })

          if (!prevInteractions)
            await UserContentInteractions.create({
              user: user._id
              // isReceivingContentEmails: !organization.corporate
            })

          return skillsToEvaluate.filter(skill => !!skill)
        } else {
          throw new Error(
            `User:${_id} or Organization:${organizationId} not found`
          )
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    onboardUserDevelopmentPlan: async (_, { inputData }, context) => {
      try {
        const user = await User.findOne({ _id: context.user._id })
        if (user) {
          await User.findOneAndUpdate(
            { _id: user._id },
            { $set: { status: 'active' } }
          )

          try {
            // REMOVE TAG WHEN USER IS ONBOARDED
            const subscriberHash = md5(user.email.toLowerCase())

            await mailchimp.lists.updateListMemberTags(listId, subscriberHash, {
              tags: [
                {
                  name: 'Onboarding',
                  status: 'inactive'
                }
              ]
            })
          } catch (err) {
            sentryCaptureException(
              `Failed to modify user ${user._id} in mailchimp list: ${err.message}`
            )
          }

          const organization = await Organization.findById(
            context.user.organizationId
          )
            .select({ approvals: 1, fulfillment: 1, corporate: 1 })
            .lean()

          // const prevProfile = await UserProfile.findOne({ user: user._id })

          const {
            neededWorkSkills,
            selectedWorkSkills,
            developmentPlan
          } = inputData

          let profile

          const mapSkills = ({ _id, name, skillLevel }) => ({
            _id,
            slug: slugfunction(name, {
              replacement: '_',
              lower: true
            }),
            level: skillLevel
          })

          const mappedNeededSkills = neededWorkSkills.map(mapSkills)

          const mappedNeededSkillsForGoalName = neededWorkSkills.map(
            ({ _id, name }) => ({
              _id,
              name
            })
          )

          const mappedSelectedSkills = selectedWorkSkills.map(mapSkills)

          const finalNeededSkills = mappedNeededSkills.map(({ _id, slug }) => ({
            _id,
            slug
          }))

          const finalNeededSkillsForGoalName = mappedNeededSkillsForGoalName.map(
            ({ _id, name }) => ({
              _id,
              name
            })
          )

          const finalSelectedSkills = new GokuArray([
            ...mappedNeededSkills.filter(({ level }) => level > 0),
            ...mappedSelectedSkills
          ])
            .unique(({ _id }) => String(_id))
            .toArray()

          if (finalNeededSkills.length > 0) {
            // if (prevProfile) {
            profile = (
              await UserProfile.findOneAndUpdate(
                { user: user._id },
                {
                  $set: {
                    neededWorkSkills: finalNeededSkills,
                    selectedWorkSkills: finalSelectedSkills
                  }
                },
                { new: true }
              )
            )._doc
          }

          if (!profile)
            profile = await UserProfile.findOne({ user: user._id }).lean()

          await recordUsersProgress(profile, [
            'selectedWorkSkills',
            'neededWorkSkills'
          ])

          if (organization.corporate) {
            const onboardingPath = await LearningPathTemplate.findOne({
              organization: context.user.organizationId,
              onboarding: true
            })
              .select({ _id: 1 })
              .lean()
            if (onboardingPath)
              try {
                await context.dataSources.LearningPath.transform({
                  organization: context.user.organizationId,
                  userId: context.user._id,
                  id: onboardingPath._id,
                  targetUser: context.user._id,
                  forApproval: false
                })
              } catch (e) {}
          } else if (developmentPlan.length > 0) {
            const goal = await Goal.create({
              goalName: generateNameForSkills(finalNeededSkillsForGoalName),
              goalType: 'PERSONAL',
              setBy: user._id,
              organizationId: context.user.organizationId,
              user: user._id,
              relatedSkills: finalNeededSkills.map(({ _id }) => _id),
              status: 'ACTIVE',
              autogenerated: true
            })

            const pullResult = await DevelopmentPlan.findOneAndUpdate(
              { user: user._id },
              {
                $pull: {
                  content: {
                    contentId: {
                      $in: developmentPlan.map(({ contentId }) => contentId)
                    }
                  }
                }
              }
            )

            if (pullResult) {
              const { content: existingContent } = pullResult

              const updatedContent = await Promise.all(
                developmentPlan
                  .filter(
                    ({ contentId }) =>
                      !existingContent.some(
                        ({ contentId: existingId }) =>
                          String(existingId) === String(contentId)
                      )
                  )
                  .map(mapApprovals(organization, context, goal))
              )

              await DevelopmentPlan.findOneAndUpdate(
                { user: user._id },
                {
                  $push: {
                    content: updatedContent
                  },
                  $set: {
                    selectedGoalId: goal._id
                  }
                }
              )

              await Goal.updateOne({ _id: goal._id }, { seen: true })
            } else {
              await DevelopmentPlan.create({
                user: user._id,
                setBy: user._id,
                organizationId: context.user.organizationId,
                content: await Promise.all(
                  developmentPlan.map(mapApprovals(organization, context, goal))
                ),
                selectedGoalId: goal._id
              })

              await Goal.updateOne({ _id: goal._id }, { seen: true })
            }
          }

          return 'OK'
        } else {
          sentryCaptureException(`User ${context.user._id} not found!`)
          return 'NOT FOUND'
        }
      } catch (e) {
        sentryCaptureException(e)
        return 'ERROR'
      }
    },
    profileSkillsChangeMutation: async (_, { inputData }, context) => {
      try {
        const user = await User.findOne({ _id: context.user._id })

        if (user) {
          const newProfile = await UserProfile.findOneAndUpdate(
            { user: user._id },
            {
              $set: {
                [inputData.key]: inputData.skills
              }
            },
            { new: true }
          )

          await recordUsersProgress(newProfile._doc, [inputData.key])

          // Clear current content data
          await UserContentInteractions.findOneAndUpdate(
            { user: user._id },
            {
              $set: {
                currentContent: []
              }
            }
          )
          return newProfile
        } else {
          console.log('USER NOT FOUND!')
          return null
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    profilePositionChangeMutation: async (_, { inputData }, context) => {
      try {
        const user = await User.findOne({ _id: context.user._id })
        if (user) {
          const newProfile = await UserProfile.findOneAndUpdate(
            { user: user._id },
            {
              $set: {
                roleId: inputData.roleId,
                roleAtWork: inputData.roleAtWork,
                relatedLineOfWork: inputData.relatedLineOfWork
              }
            },
            { new: true }
          )
          return newProfile
        } else {
          console.log('USER NOT FOUND!')
          return null
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    profileGrowthChangeMutation: async (_, { inputData }, context) => {
      try {
        const user = await User.findOne({ _id: context.user._id })
        if (user) {
          const newProfile = await UserProfile.findOneAndUpdate(
            { user: user._id },
            {
              $set: {
                selectedInterests: inputData.selectedInterests,
                neededWorkSkills: inputData.neededWorkSkills
              }
            },
            { new: true }
          )

          await recordUsersProgress(newProfile._doc, [
            'selectedInterests',
            'neededWorkSkills'
          ])
          // Clear current content data
          await UserContentInteractions.findOneAndUpdate(
            { user: user._id },
            {
              $set: {
                currentContent: []
              }
            }
          )
          return newProfile
        } else {
          console.log('USER NOT FOUND!')
          return null
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    profilePasswordChangeMutation: async (_, { inputData }, context) => {
      const { oldPassword, newPassword } = inputData
      const validPassword = await encryptor.encrypt({ digest: newPassword })
      try {
        const user = await User.findOne({ _id: context.user._id })
        if (user) {
          const validUser = await user.checkPassword(oldPassword)
          if (validUser) {
            const finalUser = await User.findOneAndUpdate(
              { _id: context.user._id },
              {
                $set: {
                  password: validPassword
                }
              },
              { new: true }
            )
            if (finalUser) {
              const additionalClaims = {}
              const userData = {
                _id: finalUser._id,
                firstName: finalUser.firstName,
                email: finalUser.email,
                roles: finalUser.roles,
                permissions: finalUser.permissions
              }
              const [token, refreshToken] = await createTokens(
                {
                  user: userData,
                  refreshTokenSecret:
                    finalUser.password + AUTH.SECRET_REFRESH_TOKEN
                },
                additionalClaims
              )
              const response = JSON.stringify({ token, refreshToken })
              return response
            }
          }
        }
      } catch (e) {
        sentryCaptureException(e)
        return new Error("You've entered a wrong password")
      }
    },
    profileNameChangeMutation: async (_, { firstName, lastName }, context) => {
      try {
        const user = await User.findOne({ _id: context.user._id })
        if (user) {
          await User.findOneAndUpdate(
            { _id: user._id },
            {
              $set: {
                firstName: firstName,
                lastName: lastName
              }
            }
          )
          return 'Success'
        } else {
          console.log('USER NOT FOUND!')
          return null
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    publicRegisterUser: async (_, { userData, metaData }, { dataSources }) => {
      try {
        const { email, firstName, lastName /*, password */ } = userData
        const { registeredFrom, withPath, subscribe } = metaData

        // const validPassword = await encryptor.encrypt({ digest: password })

        const userCheck = await User.findOne({ email })
        if (userCheck) {
          throw new Error('email_in_use')
        }
        const newUserId = new Types.ObjectId()

        const disabledSkills = await Skills.find({ enabled: false })

        const organizationName = `${firstName}'s Innential Organization`

        const slug = slugfunction(organizationName)

        const newOrganization = await Organization.create({
          organizationName,
          industry: 'N/A',
          slug,
          admins: [newUserId],
          disabledSkills,
          disabled: true
        })

        // if (!newOrganization)
        //   throw new Error(
        //     `Something went wrong while creating organization for ${email}`
        //   )

        const newUser = await User.create({
          _id: newUserId,
          // password: validPassword,
          email,
          firstName,
          lastName,
          organizationId: newOrganization._id,
          roles: [ROLES_PERMISSIONS.ADMIN.NAME, ROLES_PERMISSIONS.USER.NAME],
          permissions: [
            ...ROLES_PERMISSIONS.USER.PERMISSIONS[SCOPES.OPERATION.READ].map(
              permission => `${SCOPES.OPERATION.READ}:${permission}`
            )
          ],
          ...(registeredFrom && { registeredFrom }),
          status: 'invited',
          invitation: {
            pendingInvitation: new Types.ObjectId(),
            invitedOn: Date.now()
          },
          ...(withPath && {
            inbound: {
              path: withPath,
              engagedOn: new Date()
            }
          })
        })

        await UserProfile.create({ user: newUserId })
        await UserContentInteractions.create({ user: newUserId })

        if (withPath) {
          try {
            await dataSources.LearningPath.transform({
              organization: newOrganization._id,
              userId: newUserId,
              id: withPath,
              targetUser: newUserId,
              forApproval: false,
              firstPath: true
            })
          } catch (e) {}
        }

        if (process.env.SERVER === ENVIRONMENT.PRODUCTION) {
          if (subscribe) {
            try {
              // ADD USER TO MAILING LIST
              const response = await mailchimp.lists.addListMember(
                process.env.MAILCHIMP_VL_LIST_ID,
                {
                  email_address: email,
                  status: 'subscribed'
                }
              )
            } catch (err) {
              sentryCaptureException(err)
            }
          }
          try {
            await sendEmail(
              'contact@innential.com',
              'A user has registered to Innential',
              organizationRegisteredNotification({
                firstName,
                lastName,
                organizationName,
                organizationId: newOrganization._id,
                slug,
                withPath,
                adminAppLink: appUrls['admin']
              })
            )
          } catch (err) {
            sentryCaptureException(err)
          }
        }

        if (newUser) {
          // await sendEmail(
          //   email,
          //   'Your registration is complete',
          //   registrationTemplate({
          //     invitation: newUser.invitation.pendingInvitation,
          //     appLink: appUrls['user']
          //   })
          // )
          return newUser.invitation.pendingInvitation
        } else {
          return null
        }
      } catch (e) {
        sentryCaptureException(e)
        throw e
      }
    },
    publicRegisterUserAcceptInvitation: async (
      _,
      { pendingInvitation },
      context
    ) => {
      try {
        const user = await User.findOne({
          'invitation.pendingInvitation': pendingInvitation
        })

        if (user) {
          const { registeredFrom } = user

          try {
            // ADD USER TO MAILING LIST
            const response = await mailchimp.lists.addListMember(listId, {
              email_address: user.email,
              status: 'subscribed',
              merge_fields: {
                FNAME: user.firstName,
                LNAME: user.lastName
              }
            })
            const tags = [
              {
                name: 'Onboarding',
                status: 'active'
              },
              {
                name: 'Inbound',
                status: 'active'
              }
            ]

            switch (registeredFrom) {
              case 'lp':
                tags.push({
                  name: 'LP Page',
                  status: 'active'
                })
                break
              case 'hd':
                tags.push({
                  name: 'Homepage',
                  status: 'active'
                })
                break
              case 'csce':
                tags.push({
                  name: 'UC: Continuous Education',
                  status: 'active'
                })
                break
              case 'csob':
                tags.push({
                  name: 'UC: Onboarding',
                  status: 'active'
                })
                break
              case 'vllp':
                tags.push({
                  name: 'Virtual Library LP',
                  status: 'active'
                })
                break
              case 'vlin':
                tags.push({
                  name: 'Virtual Library Interviews',
                  status: 'active'
                })
                break
              default:
                break
            }

            // ADD TAGS
            await mailchimp.lists.updateListMemberTags(listId, response.id, {
              tags
            })

            // BEGIN ONBOARDING JOURNEY
            await mailchimp.customerJourneys.trigger(
              process.env.MAILCHIMP_ONBOARDING_JOURNEY_ID,
              process.env.MAILCHIMP_ONBOARDING_JOURNEY_STEP_ID,
              {
                email_address: user.email
              }
            )
          } catch (err) {
            sentryCaptureException(
              `Failed to add user ${user._id} to mailchimp list: ${err.message}`
            )
          }

          await analytics.trackSafe({
            userId: String(user._id),
            event: 'sign_up',
            properties: {
              registeredFrom,
              path: (user.inbound && user.inbound.path) || null
            }
          })

          return {
            user,
            onboardingInfo: await getUserOnboardingInfo(user._id)
          }
        } else {
          console.log('Invitation not found')
          return new Error('Invitation not found')
        }
      } catch (e) {
        sentryCaptureException(e)
        return null
      }
    },
    updateNeededSkills: async (_, { neededWorkSkills }, { user: { _id } }) => {
      const user = await User.findById(_id)
      if (!user) {
        sentryCaptureException(`User not found`)
        return null
      }
      const userProfile = await UserProfile.findOne({ user: _id })
      if (!userProfile) {
        sentryCaptureException(`User not onboarded`)
        return null
      }
      try {
        const newProfile = await UserProfile.findOneAndUpdate(
          { _id: userProfile._id },
          {
            $set: {
              neededWorkSkills
            }
          },
          { new: true }
        )

        await recordUsersProgress(newProfile._doc, ['neededWorkSkills'])

        // Clear current content data
        await UserContentInteractions.findOneAndUpdate(
          { user: user._id },
          {
            $set: {
              currentContent: []
            }
          }
        )
        return newProfile
      } catch (e) {
        sentryCaptureException(
          new Error('Something went wrong while updating profiles')
        )
        return null
      }
    },
    updateLearningPreferences: async (
      _,
      { types, sortMethod, price },
      { user: { _id } }
    ) => {
      if (_id !== undefined) {
        try {
          const contentProfile = await UserContentInteractions.findOne({
            user: _id
          })
          if (contentProfile) {
            if (Array.isArray(types)) {
              // TODO: CHECK IF TYPES ARE VALID (unnecessary thou?/no /enum it in db )
              await UserContentInteractions.findOneAndUpdate(
                { _id: contentProfile._id },
                {
                  $set: {
                    preferredTypes: types
                  }
                }
              )
            }
            if (sortMethod) {
              await UserContentInteractions.findOneAndUpdate(
                { _id: contentProfile._id },
                {
                  $set: {
                    sortMethod
                  }
                }
              )
            }
            if (Array.isArray(price)) {
              await UserContentInteractions.findOneAndUpdate(
                { _id: contentProfile._id },
                {
                  $set: {
                    price
                  }
                }
              )
            }
            return 'Success'
          } else {
            return 'Not found'
          }
        } catch (e) {
          sentryCaptureException(e)
          return 'Error'
        }
      }
    },
    deleteProfileImage: async (_, args, { user: { _id } }) => {
      const params = {
        Bucket: process.env.S3_BUCKET,
        Key: `users/profileImgs/${_id}` // if any sub folder-> path/of/the/folder.ext
      }
      try {
        await s3.headObject(params).promise()
        try {
          await s3.deleteObject(params).promise()
          return 'success'
        } catch (err) {
          console.log('ERROR in file Deleting : ' + JSON.stringify(err))
          return 'oops'
        }
      } catch (err) {
        console.log('File not Found ERROR : ' + err.code)
        return 'oooops'
      }
    },
    toggleWeeklyEmail: async (_, { userId }) => {
      const contentInteractions = await UserContentInteractions.findOne({
        user: userId
      })

      if (contentInteractions) {
        await UserContentInteractions.findOneAndUpdate(
          { user: userId },
          {
            $set: {
              isReceivingContentEmails: !contentInteractions.isReceivingContentEmails
            }
          }
        )
        return 'success'
      } else return new Error('User is not onboarded')
    },
    setUsersLocation: async (
      _,
      { location },
      { user: { _id, organizationId } }
    ) => {
      const organization = await Organization.findById(organizationId).lean()
      if (!organization) return null

      const prevLocation =
        organization.locations &&
        organization.locations.find(loc => loc === location)
      if (prevLocation) {
        const result = await User.findOneAndUpdate(
          { _id },
          {
            $set: {
              location
            }
          },
          { new: true }
        )
        return result
      } else return null
    },
    editDisabledProfile: async (
      _,
      { inputData },
      { user: { organizationId }, dataSources }
    ) => {
      const { firstName, lastName, user, ...profileInput } = inputData

      const userInfo = await User.findOneAndUpdate(
        { _id: user },
        {
          $set: {
            firstName,
            lastName
          }
        },
        { new: true }
      )

      let userProfile = await UserProfile.findOneAndUpdate(
        { user },
        {
          $set: profileInput
        },
        { new: true }
      )

      if (!userProfile) {
        userProfile = await dataSources.UserProfile.createOne({
          user,
          organizationId,
          ...profileInput
        })
      }

      const { _id, status, email, roles, location } = userInfo
      const { roleAtWork, roleId } = userProfile

      const imageLink = await getDownloadLink({
        key: 'users/profileImgs',
        expires: 500 * 60,
        _id
      })

      const employeeTeams = await Team.find({
        $or: [{ leader: _id }, { members: _id }],
        active: true
      })

      const previousTeams = await Team.find({
        $or: [{ leader: _id }, { members: _id }],
        active: false
      })

      const membersEvaluation = await UserEvaluation.findOne({ user: _id })
      let evaluatedSkills = []
      let rawFeedback = []
      if (membersEvaluation) {
        const { skillsFeedback } = membersEvaluation
        skillsFeedback.forEach(skill => {
          // const ownSkill = employeeProfile.selectedWorkSkills.find(s => String(s._id) === String(skill.skillId))
          evaluatedSkills.push({
            _id: skill._id,
            skillId: skill.skillId,
            // membersLevel: ownSkill ? ownSkill.level : 0,
            evaluatedLevel:
              skill.feedback.length > 0
                ? skill.feedback.reduce((acc, curr) => (acc += curr.level), 0) /
                  skill.feedback.length
                : 0
          })

          rawFeedback.push({
            _id: skill._id,
            skillId: skill.skillId,
            feedback: skill.feedback.map(({ evaluatedAt, level, _id }) => ({
              _id,
              evaluatedAt,
              evaluatedLevel: level
            }))
          })
        })
      }

      return {
        _id,
        status,
        email,
        roles,
        firstName,
        lastName,
        imageLink,
        location,
        roleAtWork,
        roleId,
        teamInfo:
          employeeTeams.length > 0
            ? employeeTeams.map(team => team.teamName)
            : [],
        previousTeams:
          previousTeams.length > 0
            ? `${previousTeams.map(team => team.teamName).join(', ')}`
            : null,
        skillsProfile: userProfile,
        evaluatedSkills,
        rawFeedback
      }
    },
    inviteDisabledUser: async (
      _,
      { userId, deleteData },
      { user: { _id, organizationId } }
    ) => {
      const user = await User.findOneAndUpdate(
        { _id: userId },
        {
          $set: {
            status: 'invited',
            invitation: {
              pendingInvitation: new Types.ObjectId(),
              invitedOn: new Date()
            }
          }
        },
        { new: true }
      )
      if (deleteData) await UserProfile.deleteOne({ user: userId })

      const addingUser = await User.findById(_id).select({
        firstName: 1,
        lastName: 1
      })
      // .lean()

      const invitingPerson = {
        name: `${addingUser.firstName} ${addingUser.lastName}`,
        roleAtWork: await addingUser.getRoleAtWork(),
        imgLink: await getDownloadLink({
          _id: addingUser._id,
          key: 'users/profileImgs',
          expires: 604800
        })
      }

      const organization = await Organization.findById(organizationId)
        .select({ organizationName: 1, corporate: 1 })
        .lean()

      if (user && addingUser) {
        const {
          email,
          invitation: { pendingInvitation: invitation }
        } = user
        const usersForEmail = await getUsersForNotification({
          organizationId
        })
        const appUrl = appUrls['user']
        appUrl &&
          (await sendEmail(
            email,
            `${invitingPerson.name} invited you to join Innential`,
            firstInvitationTemplate({
              invitingPerson,
              appUrl,
              invitation,
              organizationName:
                organization.organizationName || 'their organization',
              corporate: organization.corporate,
              users: usersForEmail,
              totalCount:
                (await User.countDocuments({
                  organizationId,
                  status: 'active'
                })) - usersForEmail.length
            })
          ))
        return 'OK'
      } else {
        sentryCaptureException(
          new Error(`User not found: FROM ${_id} TO ${userId}`)
        )
        return 'not_found'
      }
    },
    assessSkills: async (_, { skills }, { user: { _id: user } }) => {
      await UserProfile.findOneAndUpdate(
        { user },
        {
          $pull: {
            selectedWorkSkills: {
              _id: { $in: skills.map(({ _id }) => _id) }
            }
          }
        }
      )

      const result = await UserProfile.findOneAndUpdate(
        { user },
        {
          $addToSet: {
            selectedWorkSkills: skills
          },
          $set: {
            updatedAt: new Date()
          }
        },
        { new: true }
      )

      await recordUsersProgress(result._doc, ['selectedWorkSkills'])

      return result
    },
    disableApprovalPrompt: async (_, args, { user: { _id } }) => {
      return User.findOneAndUpdate(
        { _id },
        {
          $set: {
            approvalPromptDisabled: true
          }
        },
        { new: true }
      )
    }
  }
}
